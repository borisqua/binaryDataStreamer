"use strict";
const
  Helpers = require('../helpers')
  , {Tools} = require('mbeeg')
  , {remote, ipcRenderer} = require('electron')
  , {TweenMax, TimelineMax} = require('gsap')
;
let
  config = remote.getGlobal('config')
;

class Keyboard {
  constructor({
                stimuli
              }) {
    this.stimuli = stimuli;
    
    //DOM elements
    this.viewport = $("#keyboard");
    this.output = $('.line');
    this.window = $(window);
    this.monitor = $(`#monitor`);
    this.body = $(document.body);
    
    this._windowCaption = 90;
    //debug
    // this.prevStimTStamp = 0;
    
    // ----- PRIVATE METHODS -----
    
    /**
     * to change styles of stimulus keybox to make oddball
     * @param stimulus - reference to stimulus vector - [timestamp, key, target_flag, cycle_counter]
     * @private
     */
    this._stimulate = stimulus => {
      if (!stimulus[0])//no timestamp (timestamp value === 0)
        return;
      let key = $(`.key[index="${stimulus[1]}"]`);
      ipcRenderer.send(`ipcKeyboard-stimulus`, stimulus);
      Helpers.stimulusOn(key, config);
      setTimeout(() => { Helpers.stimulusOff(key, config); }, config.mbeeg.stimulation.duration);
      
      // console.log(`stimulus ${stimulus}; delta ${stimulus[0] - this.prevStimTStamp}`);//for debug
      // this.prevStimTStamp = stimulus[0];//for debug
    };
    
    /**
     * switch off stimulation and darken keys while pause after next decision
     * @private
     */
    this._unboundStimuli = () => {
      let keys = $('.key');
      this.stimuli.removeAllListeners();
      this.stimuli.unbound();
      keys.addClass(`faded-${config.carousel.appearance.colorScheme.selected}-keys`);
      setTimeout(() => {
        this.stimuli.bound();
        keys.removeClass(`faded-${config.carousel.appearance.colorScheme.selected}-keys`);
        this.stimuli.on('data', stimulus => this._stimulate(stimulus));
      }, this.pauseAfterDecision);
    };
    
    /**
     * put into input field an asterisk (*) if no selection recognized, or put recognized selection symbol
     * highlight selected and darken non-selected keys during this.pauseAfterDecision
     * @param keyIndex
     * @private
     */
    this._putSymbol = keyIndex => {
      let
        inputField = document.getElementById("inputField"),
        key = $(`.key[index="${keyIndex}"]`)
      ;
      if (keyIndex === -1) {
        inputField.value = inputField.value + '*';
      } else {
        inputField.value = inputField.value + config.carousel.keyboard.keys[keyIndex].symbol;
      }
      this._unboundStimuli();
      key.addClass(`selected-${config.carousel.appearance.colorScheme.selected}-key`);
      setTimeout(() => {
        key.removeClass(`selected-${config.carousel.appearance.colorScheme.selected}-key`);
      }, this.pauseAfterDecision);
      inputField.focus();
      inputField.scrollTop = inputField.scrollHeight;
    };
    
    /**
     * place new tweenbox to the initial position in viewport and returns reference to tween associated with tweenbox
     * @param keyIndex - key index in Keys array
     * @return {TweenMax}
     * @private
     */
    this._getKeybox = keyIndex => {//create div & tween for it (keyIndex - key index in Keys array)
      let keybox = $(`<div class="key" index="${keyIndex}">${config.carousel.keyboard.keys[keyIndex].symbol}</div>`);
      keybox.css({
        width: config.carousel.keyboard.keybox.width,
        height: config.carousel.keyboard.keybox.height,
        margin: config.carousel.keyboard.keybox.margin,
        border: `${config.carousel.keyboard.keybox.borderWidth}px solid #525252`
      });
      
      this.viewport.append(keybox);
      
      TweenMax.set(keybox, {
        x: this.startKeyboxPosition,
        y: config.carousel.keyboard.keys[keyIndex].row * this.verticalKeyboxDelta + 0.5 * (this.verticalKeyboxDelta - config.carousel.keyboard.keybox.height)
      });
      
      Draggable.create(keybox, {
        type: "x,y",
        onPress: () => {
          for (let i = 0; i < config.carousel.keyboard.schools.length; i++) {
            this.timelines[i].kill();
          }
        }
      });
      
      // noinspection JSValidateTypes
      return new TweenMax(keybox
        , config.carousel.keyboard.motion.tweenDuration
        , {
          x: this.endKeyboxPosition,
          ease: SlowMo.ease.config(0.9, 0.2, false),
          // ease: "linear",
          repeat: -1
        });
    };
    
    /**
     * build timeline for specific school of keys
     * @param schoolIndex - index in array of groups of elements with same movement rules
     * @return TimelineMax object
     * @private
     */
    this._buildTimeline = schoolIndex => {
      let timeline = new TimelineMax();
      for (let i = 0; i < config.carousel.keyboard.keys.length; i++) {
        if (config.carousel.keyboard.keys[i].school === schoolIndex) {
          let
            column = config.carousel.keyboard.keys[i].column
            , row = config.carousel.keyboard.keys[i].row
            , index = row * config.carousel.keyboard.viewport.columns + config.carousel.keyboard.viewport.columns - column - 1 //last column in each row moves first
          ;
          timeline.add(this._getKeybox(index), column * this.horizontalKeyboxPeriod);
        }
      }
      timeline.addLabel(`initialPosition${schoolIndex}`, this.initialTimePosition);
      return timeline;
    };
    
    /**
     * init keyboard properties from config object literal
     * @param config - reference to object literal with all relevant to application data
     * @return {Keyboard} - returns 'this' to support method chaining
     * @private
     */
    this._init = () => {
      
      // geometry and positions calculation
      this.minHorizontalKeyboxDelta = config.carousel.keyboard.keybox.width + 2 * config.carousel.keyboard.keybox.margin +
        (config.carousel.keyboard.keybox.showBorder ? config.carousel.keyboard.keybox.borderWidth * 2 : 0);
      this.horizontalKeyboxDelta = config.carousel.keyboard.viewport.width / config.carousel.keyboard.viewport.columns;
      this.horizontalKeyboxDelta = this.horizontalKeyboxDelta < this.minHorizontalKeyboxDelta ?
        this.minHorizontalKeyboxDelta : this.horizontalKeyboxDelta;
      
      this.minVerticalKeyboxDelta = config.carousel.keyboard.keybox.height + 2 * config.carousel.keyboard.keybox.margin
        + (config.carousel.keyboard.keybox.showBorder ? config.carousel.keyboard.keybox.borderWidth * 2 : 0);
      this.verticalKeyboxDelta = config.carousel.keyboard.viewport.height / config.carousel.keyboard.viewport.rows;
      this.verticalKeyboxDelta = this.verticalKeyboxDelta < this.minVerticalKeyboxDelta ?
        this.minVerticalKeyboxDelta : this.verticalKeyboxDelta;
      
      this.minViewportWidth = this.horizontalKeyboxDelta * config.carousel.keyboard.viewport.columns;
      this.viewportWidth = config.carousel.keyboard.viewport.width;
      this.viewportWidth = this.viewportWidth < this.minViewportWidth ? this.minViewportWidth : this.viewportWidth;
      
      this.minViewportHeight = this.verticalKeyboxDelta * config.carousel.keyboard.viewport.rows;
      this.viewportHeight = config.carousel.keyboard.viewport.height;
      this.viewportHeight = this.viewportHeight < this.minViewportHeight ? this.minViewportHeight : this.viewportHeight;
      
      this.startKeyboxPosition = config.carousel.keyboard.motion.shift * this.horizontalKeyboxDelta;
      this.endKeyboxPosition = this.viewportWidth + config.carousel.keyboard.motion.shift * this.horizontalKeyboxDelta;
      
      this.horizontalKeyboxPeriod = config.carousel.keyboard.motion.tweenDuration / config.carousel.keyboard.viewport.columns;
      let
        velocity = (this.endKeyboxPosition - this.startKeyboxPosition) / config.carousel.keyboard.motion.tweenDuration,
        gap = (this.horizontalKeyboxPeriod * velocity - config.carousel.keyboard.keybox.width) / velocity,
        shift = this.horizontalKeyboxPeriod * config.carousel.keyboard.motion.shift
      ;
  
      this.initialTimePosition = this.horizontalKeyboxPeriod *
        (config.carousel.keyboard.viewport.columns - 1) + 0.5 * gap - shift;
      
      this.pauseAfterDecision = config.mbeeg.stimulation.pauseAfterDecision;
      
      return this;
    };
    
    /**
     * redraw viewport and refill timelines with current window size & config settings
     * without resizing window
     * @return {Keyboard} - returns 'this' to support method chaining
     * @private
     */
    this._redraw = () => {
      //redraw & refresh content of viewport and output field
      this.viewport
        .html("")
        .css({
          minWidth: this.minViewportWidth,
          minHeight: this.minViewportHeight,
          width: this.viewportWidth,
          height: this.viewportHeight,
          left: 0,
          top: 0
        });
      this.output.css({
        minWidth: this.minViewportWidth,
        width: this.viewportWidth,
      });
      //refill timelines
      this.timelines = [];
      for (let i = 0; i < config.carousel.keyboard.schools.length; i++) {
        this.timelines.push(this._buildTimeline(i));
        this.timelines[i]
          .timeScale(config.carousel.keyboard.schools[i].motion.speedScale)
          .seek(`initialPosition${i}`)
        ;
      }
      return this;
    };
    
    /**
     * resize keyboard window to fit with viewport size
     * @return {Keyboard} - returns 'this' to support method chaining
     * @private
     */
    this._fitWindowSizeToViewport = () => {
      window.resizeTo(
        this.viewportWidth + 2 * (+this.output.css("margin").match(/\d+/)[0] + +this.output.css("border-width").match(/\d+/)[0]),
        this.viewportHeight + +this.viewport.css("margin-top").match(/\d+/)[0] + this.monitor.outerHeight(true) + this._windowCaption
      );
      return this;
    };
    
    /**
     * reset of stimuli with settings from application config.json
     * @return {Keyboard} - returns 'this' to support method chaining
     * @private
     */
    this._resetStimuli = () => {
      //reset stimuli
      this.stimuli.reset({
        stimuliIdArray: config.mbeeg.stimulation.sequence.stimuli,
        duration: config.mbeeg.stimulation.duration,
        pause: config.mbeeg.stimulation.pause
      });
      return this;
    };
    
    // ----- EVENT HANDLERS -----
    
    this.timeout = {};
    this.window
      .on('resize', () => {
        clearTimeout(this.timeout);
        let
          viewportWidth = this.window.outerWidth(true)
            - 2 * (+this.output.css("margin").match(/\d+/)[0] + +this.output.css("border-width").match(/\d+/)[0])
          ,
          viewportHeight = this.window.outerHeight(true) - +this.viewport.css("margin-top").match(/\d+/)[0]
            - this.monitor.outerHeight(true) - this._windowCaption
        ;
        console.log(`width delta ${this.viewportWidth - viewportWidth}; height delta ${this.viewportHeight - viewportHeight}`);
        config.carousel.keyboard.viewport.width = viewportWidth;
        config.carousel.keyboard.viewport.height = viewportHeight;
        
        this.timeout = setTimeout(() => {//unbounced actions
          ipcRenderer.send(`ipcKeyboard-change`, config);//stimuli reset => epochs reset => epoch series reset => save keyboard configuration changes
          this._init()._redraw();
          Helpers.reloadSchema(config);
        }, 200)
      });
    
    //show stimulus animation on stimuli data received event
    this.stimuli.on('data', stimulus => this._stimulate(stimulus));
    
    //ipc messaging
    ipcRenderer.on('ipcApp-decision', (e, decision) => {
      this._putSymbol(decision);
    });
    
    // ----- START KEYBOARD -----
    this
      ._init(config)
      ._redraw()
      ._resetStimuli()
      ._fitWindowSizeToViewport();
  }
  
  /**
   * input string setter
   * @param {*} value - value to store to input field
   */
  set inputString(value) { this.output.val(value); }
  
  // noinspection JSUnusedGlobalSymbols
  /**
   * input string getter
   * @return {*} - returns value from input field
   */
  get inputString() { return this.output.val(); }
  
  /**
   * init keyboard
   * @param config - reference to object literal with all relevant to application data
   * @return {Keyboard} - returns 'this' to support method chaining
   */
  init(config) {
    return this._init(config);
  }
  
  /**
   * init and run keyboard
   * @param config - reference to object literal with all relevant to application data
   * @return {Keyboard} - returns 'this' to support method chaining
   */
  run(config) {
    this
      ._init(config)
      ._redraw()
      ._resetStimuli()
      ._fitWindowSizeToViewport();
    return this;
  }
  
  /**
   * reset keyboard properties to fit keys to the viewport and redraw keyboard window to fit viewport size
   * @param config - reference to object literal with all relevant to application data
   * @return {Keyboard} - returns 'this' to support method chaining
   */
  autofit(config) {
    // reset tween parameters (t=S/V)
    config.carousel.keyboard.viewport.width = ((config.carousel.keyboard.keybox.showBorder ? config.carousel.keyboard.keybox.borderWidth * 2 : 0)
      + config.carousel.keyboard.keybox.width + config.carousel.keyboard.keybox.margin * 2) * config.carousel.keyboard.viewport.columns;
    
    config.carousel.keyboard.viewport.height = ((config.carousel.keyboard.keybox.showBorder ? config.carousel.keyboard.keybox.borderWidth * 2 : 0)
      + config.carousel.keyboard.keybox.height + config.carousel.keyboard.keybox.margin * 2) * config.carousel.keyboard.viewport.rows;
    
    this
      ._init(config)
      ._redraw()
      ._fitWindowSizeToViewport()
    ;
    
    ipcRenderer.send(`ipcKeyboard-change`, config);//stimuli reset => epochs reset => epoch series reset => save keyboard configuration changes
    
    return this;
    
  }
  
  /**
   * drops all symbols into start position and sets timeScale into zero (no movements) if stop == true
   * @param schools - array of groups of elements with the same movement rules
   * @return {Keyboard} - returns 'this' to support method chaining
   */
  initialState(schools) {
    for (let i = 0; i < schools.length; i++) {
      this.timelines[i]
        .seek(`initialPosition${i}`)
        .timeScale(0);
    }
    return this;
  }
  
  /**
   * to change motion properties of keyboard on the fly
   * @param schools - array of groups of elements with the same movement rules
   * @return {Keyboard} - returns 'this' to support method chaining
   */
  motionChange(schools) {
    for (let i = 0; i < schools.length; i++) {
      this.timelines[i].timeScale(schools[i].motion.speedScale); //speedScale - scale factor of speed value (defined by config.carousel.keyboard.motion.tweenDuration)
      // if (config.carousel.keyboard.schools[i].motion.reverse && !this.timelines[i].reversed)
      //   this.timeLines[i].reverse();
      // else
      //   this.timeLines[i].play();
    }
    return this;
  }
  
}

module.exports = Keyboard;
